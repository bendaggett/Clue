The infrastructure for my code contains 3 .c files and their corresponding header files, each of which are dedicated to one of the structures in the program: room, item, and 
character. The files all contain a constructor, which uses malloc to allocate memory for each structure. Each file also contains any mutator functions needed.

For items.c,  the add and drop item functions have essentially the same implementation. These methods will take an item name and a pointer to the player struct. They iterate through the item list of the room or player, using strcmp to determine where the names corresponding item is in the list. They then store the item in a temporary node and unlink the node by setting its predecessor to the next node. They then iterate through the correct structures list and place the item stored in a temporary node into the end of the list. 

The move_character function in characters.c has a similar implementation to the item methods. This method takes two structures, a character structure and a room structure. The character structure contains a pointer to the character's current room, so the function can use this pointer to iterate to the end of the room's character list and remove the character using a similar method to add_item. Once the player is unlinked, a temporary node iterates to the end of the destination room and places the character there. The character's room pointer is also updated to the destination room.

The bulk of the code is in adventure.c. This file contains accessor functions and runs the game. The main function first initializes the game board, creating a randomly generated board of rooms, items, and characters. To randomize the board, I put the names of each item, room and character into respective arrays. These arrays were looped, each time picking a random index and putting the value into a new array, effectively randomizing the placements. These names are then put into pre-created structures. This makes the cross referencing of names and structures very efficient, as all one has to do is reference an index of the scrambled array, and its corresponding strucutre. To generate a random answer, another array of strings is created, with a slot for the item, room, and character. These slots are filled when generating the scrambled arrays, as we can just use the random numbers from that process to also select answers. I randomized the players starting position separately from the other characters so they would not always end up on the same part of the board. This was done using the random number and a series of if statements, each of which corresponded to a specific starting area. I wanted each space to have at least one item or character, so I preset the number of structures in each so that it would be evenly distributed. 

Once everything is initialized, the game starts with a while loop, which checks if the player has used up all 10 of their guesses. I use getline() to retrieve an input command from the player, and divide each line into a command and an argument, which are delimited by spaces useing strtok(). A series of if statements pairs each command with a function. Some of these commands call the mutator functions from the other files. The move_character method has two uses, in the 'go' command and 'clue command'. Go simply determines what direction to pass to the move_character function, and passes that along with the avatar. The clue function first calls move_character on the specified character to bring it to the player's room. Then it iterates through the players and rooms item lists, as well as the room's character list to see if there are matches. If there are 3 matches, the function returns int 1 and the main loop is broken. If it returns 0, the number of guesses is incremented by one, and if it returns -1, that means that there is an invalid input. The rest of the commands are print statements or accessor functions that simply provide information to the player. Once the while loop is broken, the memory for each structure is freed. 

youtube video link: https://youtu.be/TJ3gc_VJmlE	
